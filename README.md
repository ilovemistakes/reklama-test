[![Build Status](https://travis-ci.org/ilovemistakes/reklama-test.svg?branch=master)](https://travis-ci.org/ilovemistakes/reklama-test)

Тестовое задание для reklama.guru
---------------------------------

### Условия задачи ###
На вход от пользователя поступает имя файла (с путем).
Файл содержит столбец с датой, и несколько измерений
Например:
```
date; A; B; C
2018-03-01; 3; 4; 5.05
2018-03-01; 1; 2; 1
2018-03-01; 2; 2; -0.05
2018-03-02; 5; 7; 6.06
2018-03-03; 1; 2; 1.06
```
Нужно вывести данные сгруппированные и просумированные по дате:
```
date; A; B; C
2018-03-01; 6; 8; 6
2018-03-02; 5; 7; 6.06
2018-03-03; 1; 2; 1.06
```
Размер данных таков, что ни исходный файл, ни даже результат аггрегации не поместятся в память.
Код покрыть тестами.
Желательна версия на php и go

### Решение ###

В рамках задачи было написано несколько алгоритмов для сравнения эффективности по скорости обработки и потреблению памяти на разных размерах входных данных:

- **in-memory** - самое простое решение "в лоб" - посчитать всё в памяти. Формально не является решением задачи, т.к. не влезает по памяти, но может служить отправной точкой при сравнении эффективности других алгоритмов.
- **seeker** - проходим входной файл и для каждой даты запоминаем все позиции в файле, где эта дата встречается. Затем для каждой даты вычитываем соответствующие строчки, суммируем и записываем в выходной файл.
- **binary** -  Группировка и суммирование за один проход по входному файлу. Используется промежуточный двоичный буфер, в котором заведомо известен размер одной строки данных в байтах, что позволяет мгновенно адресовать данные. Также используется "индексный" файл, в котором для каждой даты хранится смещение блока с результирующими данными в двоичном буфере. Сделан для уменьшения количества считываемых данных при поиске в индексе и с заделом на оптимизацию.
Для каждой строки входящих данных мы ищем в индексном файле адрес выходных
данных. Если нашли, то считываем их из буфера, суммируем с текущей строчкой
и записываем обратно. Если не нашли, то дописываем блок в конец буфера и добавляем
в индекс адрес блока. После обработки всех входных данных разворачиваем
двоичный буфер в человекочитаемый формат.
- **binary-indexed** - то же самое, что и **binary**, только индекс (адреса результирующих блоков) хранится в памяти (в обычном ассоциативном массиве).

На небольших объёмах данных самым толковым оказался алгоритм **seeker**. Но он предполагает, что в память влезут все даты с позициями всех строк во входном файле. Для больших объёмов входных данных это проблема, и её решает **binary-indexed** алгоритм, который и используется по умолчанию. Он ест значительно меньше памяти, позволяет обрабатывать входящие данные по мере поступления, но и выполняется медленнее:

```
$ bin/console generate-input-data --line-count=1000000 --column-count=10 --day-count=100000 input.txt
Готово.
```

```
$ bin/console aggregate --aggregator=seeker input.txt output.txt
Чтение входного файла...
 62998691/62998691 [============================] 100%
Суммирование и запись выходного файла...
 99996/99996 [============================] 100%
Готово.
Пиковое выделение памяти: 89 Мб.
Время выполнения скрипта: 0м 55с.
```

```
$ bin/console aggregate --aggregator=binary-indexed input.txt output.txt
Обработка данных...
 62998691/62998691 [============================] 100%
Запись выходного файла...
 99996/99996 [============================] 100%
Готово.
Пиковое выделение памяти: 13 Мб.
Время выполнения скрипта: 1м 14с.
```

Также, была предпринята попытка сделать алгоритм агрегации прямо "по месту" - бежим по файлу, запоминаем даты и их позиции в файле. Если текущая дата встречается первый раз, то пропускаем её. Если уже встречалась ранее, то считываем ту строчку, суммируем с текущей строчкой и записываем поверх первой строки. Но для этого необходимо уметь мгновенно (O(1)) записывать новые просуммированные значения поверх старых, а это невозможно в текстовом представлении. Значит, нужно конвертировать в двоичный формат с фиксированным размером блока. Но в первом приближении алгоритм показал себя плохо - очень много времени уходило на конвертацию из текстового формата в двоичный и обратно.

### Запуск ###

* Установка зависимостей: `composer install`
* Обработка данных: `bin/console aggregate input.txt output.txt`
* Генерация случайных входных данных: `bin/console generate-input-data input.txt`

### Тестирование ###

* Запуск юнит-тестов: `vendor/bin/phpunit`
* TravisCI - https://travis-ci.org/ilovemistakes/reklama-test
